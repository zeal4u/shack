template<class Pointer>
class AtomicMarkablePointer{
private:
    std::atomic<Pointer> ptr;
    const int32_t Marked = 0x00000001;
    const int32_t UnMraked = 0x00000000;
public:
    explicit AtomicMarkablePointer(Pointer p, bool mark){
        ptr.store((Pointer)((int32_t)p | (int32_t)mark));
    }
    AtomicMarkablePointer(const AtomicMarkablePointer &a){
        ptr.store(a.ptr.load());
    }
    AtomicMarkablePointer operator = (const AtomicMarkablePointer &a){
        if (*this != a){
            ptr.store(a.ptr.load());
        }
        return *this;
    }
    Pointer getReference() const {
        Pointer p = ptr.load();
        return (bool)((int32_t)p & Marked) ? (Pointer)((int32_t)(p)& ~Marked) : p;
    }
    bool isMarked() const {
        Pointer p = ptr.load();
        return (bool)((int32_t)p & Marked);
    }
    Pointer get(bool &b) const {
        Pointer p = ptr.load();
        b = (bool)((int32_t)p & Marked);
        return b ? (Pointer)((int32_t)(p)& ~Marked) : p;
    }
    bool compareAndSet(Pointer expectedPointer, Pointer newPointer,
        bool expectedMark, bool newMark){
        Pointer p = ptr.load();
        bool b = (bool)((int32_t)p & Marked);
        if (b == expectedMark){
            expectedPointer = (Pointer)((int32_t)expectedPointer | (int32_t)b);
            return ptr.compare_exchange_strong(expectedPointer, (Pointer)((int32_t)newPointer | (int32_t)newMark));
        }
        return false;
    }
    void set(Pointer newPointer, bool newMark){
        newPointer = (Pointer)((int32_t)newPointer | (int32_t)newMark);
        ptr.exchange(newPointer);
    }
    bool attemptMark(Pointer expectedPointer, bool newMark){
        Pointer newPointer = (Pointer)((int32_t)expectedPointer | (int32_t)newMark);
        expectedPointer = isMarked() ? (Pointer)((int32_t)expectedPointer | Marked) : expectedPointer;
        return ptr.compare_exchange_strong(expectedPointer, newPointer);
  }
};
